[{"lang":"en","lvl2":"Pre-requisites\nDevelopment stack\nDeployment capabilities/integration\nTesting","text":"Ensure to use java >= 11\n(Optional) Ensure to use a dependency manager such as Apache Maven/Gradle/SBT or Apache Ivy.\nusing SDKMan can greatly simplify the installation.\nThe goal of µShip is to promote and enable JSON-RPC development at scale. For that it provides a CDI-Servlet integration module known as jsonrpc-core module.\nHowever, µShip also provides all the underlying stack to make it functional such as:\nAn embedded Servlet container (Apache Tomcat),\nJSON-P/JSON-B integration modules,\nJSON-RPC API/implementation and documentation utilities.\nas of today, µShip does not go further - as providing a configuration/openmetrics/opentracing/JWT integration since these ones can easily be added using CDI libraries. It will probably be tackled in a few versions but was not a pre-requisite of the project.\nRead more.\nBy using CDI standalone (a.k.a. CDI SE) and an embedded Apache Tomcat, µShip enables to deliver application as:\nAssemblies (just use java -cp folder-with-dependencies-and-application-jars/*.jar com.app.YourMain - or reuse µShip main),\nDocker images using jib-maven-plugin.\nby using a flat classpath, µShip is perfectly compatible with java CDS which boosts a lot the startup in general, don’t hesitate to set it up if you care to start in less than a second.\nOnce again, by using a plain CDI base, testing is made easy and compatible with Apache OpenWebBeans tooling.","title":"Getting Started","url":"//yupiik.github.io/uship/getting-started.html"},{"lang":"en","text":"","title":"Index","url":"//yupiik.github.io/uship/index.html"},{"lang":"en","lvl2":"Launcher\nCreate docker images","text":"To launch UShip, you just have to launch a CDI SE container. Using default implementation - Apache OpenWebBeans - it can be done using the default main(String…): org.apache.openwebbeans.se.CDILauncher. For the web server you can use --openwebbeans.main uShipTomcatAwait argument with CDILauncher to await Tomcat server and not quit immediately.\nOnce you collected all dependencies to be able to build the application classpath, simply set this class a your main and your application will start.\nWe highly recommend using JIB to create the docker images but you can also use a plain Dockerfile if desired. This documentation will use jib to provide an end to end example.\nHere is how to define Jib plugin to create a docker image:\nOnce configured you can build a local docker image using: mvn package jib:dockerBuild.\nusing mvn package jib:build, you can push the image to a remote registry without docker daemon. See jib documentation for more details.","title":"Packaging","url":"//yupiik.github.io/uship/packaging.html"},{"lang":"en","lvl2":"Testing an UShip application","text":"Testing an UShip application just requires to launch a CDI container. By default we rely on org.apache.openwebbeans:openwebbeans-junit5 to do so. It enables to start the container marking the test class with @Cdi:\nMark the test class to need a CDI SE container,\n@Cdi makes the test instance injections aware,\nThen simply write your tests as usual.\n@Cdi has some configuration options. One of the most interesting is to set reusable = true. It will enable to use the same container for all tests. Since, with this mode, all tests of the suite (configurable in surefire) must use the same flag, you can define a JUnit 5 stereotype:\nNow, instead of using @Cdi, you can use @MyAppSupport on test classes avoiding to miss a reusable = true configuration. It is also very useful to add extension to all tests at once, for example if you have some JPA enhancer to execute before the container starts or some entity spying to auto delete test data between test, you can add the extensions there:\nThe test will then not change:","title":"Testing","url":"//yupiik.github.io/uship/testing.html"},{"lang":"en","lvl2":"Setup your JSON-RPC service with µship stack\nCreate JSON-RPC endpoints\nDocument JSON-RPC endpoints\nGoing further","text":"To get started, you have to create a new project. This part will use Maven to illustrate the process but it is easily adaptable to Gradle or any Java based project.\nTo create a new Apache Maven project, you can use mvn archetype:generate but we recommend you to just create a folder and manually write a pom to avoid to inherit from a legacy setup.\nHere is a pom.xml template you can use to get started:\nEnsure to define your project metadata, note that this setup will be compatible with a multi-module project too,\nDefine uship version as a variable for easier upgrades (not required),\nWe use Yupiik Logging to get a more cloud friendly logging but this is not required at all, skip this dependency if not desired (if you prefer Log4j2 or so use JUL binding for example),\nWe want to write tests with JUnit 5 so we set it as dependency,\nJUnit 5.8.0-M1 got a pom bug so we force kotlin exclusion to workaround it,\nWe import the UShip bom to get dependencies versions right,\nWe force the encoding for resources to avoid surprises (OS dependent otherwise),\nWe force the compiler to use the Java version we want (note you can use any version >= 11),\nWe force surefire version to ensure we are JUnit 5 compatible,\nWe prevent surefire to trim the stack when an exception is thrown - it swallows the information you need to understand why it failed in general,\nWe force Yupiik logging manager (if you don’t use Yupiik Logging, skip it).\nµship does not use a parent pom to set it up automatically because: 1. it can quickly get outdated with transitive dependencies and project must be able to update any of the plugin/dependencies without a new µship release for flexibility, 2. you can use other plugins (junit-platform-maven-plugin instead of maven-surefire-plugin for example, spock, etc…), 3. it is saner to use a project related parent than a cross-project parent which is a bad practise and breaks several Maven features/integrations.\nAt that stage we have a good \"parent\" pom but to be able to code against it you should add the related dependencies. The simplest is to add this dependency:\nFrom here you can develop JSON-RPC endpoints.\nCreating a JSON-RPC endpoint is about marking a bean with the qualifier @JsonRpc and some method(s) with @JsonRpcMethod:\nDefines the class as containing JSON-RPC methods,\nSince the class will match a CDI bean, it can use any relevant scope. We strongly encourage you to use @ApplicationScoped if possible for performances and consistency but it is not required,\n@JsonRpcMethod defines a method usable over JSON-RPC transport (a servlet by default). The name attribute must be unique per deployment and we highly recommend you to set the documentation attribute,\nThe method can then define its return type and inputs as any JSON-B friendly types. Inputs can be marked with @JsonRpcParam to set their documentation.\nthe JSON-RPC implementation supports by position calls (parameters are passed in order) or names (JsonRpcParam#value). If not explicitly set, the name is taken from the parameter bytecode name. It is highly recommended to set -parameters to javac to get the same names than in the source code. Also take care that the order and names are then part of your contract.\nIf fully described - documentation methods being set in annotations, you can generate your endpoint documentation using jsonrpc-documentation module and in particular io.yupiik.uship.jsonrpc.doc.AsciidoctorJsonRpcDocumentationGenerator class.\nYou have to add this dependency to your pom.xml:\nThen add new exec build plugin instructions:\nWill generate a textual (Asciidoctor) documentation of your contract from the classes listed in the arguments,\nWill generate an OpenRPC (JSON) contract from the classes listed in the arguments.\nIt is possible to enrich the JSON-RPC protocol, in particular bulk request support, by reusing io.yupiik.uship.jsonrpc.core.impl.JsonRpcHandler class in your own endpoints. Typical examples are endpoint wrapping a set of request (sub methods), in a single transaction, endpoints propagating a state between method calls (like the second method will get the id generated in the first one), etc…","title":"Usage","url":"//yupiik.github.io/uship/development-stack.html"}]