[{"lang":"en","lvl2":"Pre-requisites\nDevelopment stack\nDeployment capabilities/integration\nTesting\nHTTP Server\nHTTP Client","text":"Ensure to use java >= 11\n(Optional) Ensure to use a dependency manager such as Apache Maven/Gradle/SBT or Apache Ivy.\nusing SDKMan can greatly simplify the installation.\nThe goal of µShip is to promote and enable JSON-RPC development at scale. For that it provides a CDI-Servlet integration module known as jsonrpc-core module.\nHowever, µShip also provides all the underlying stack to make it functional such as:\nAn embedded Servlet container (Apache Tomcat),\nJSON-P/JSON-B integration modules,\nJSON-RPC API/implementation and documentation utilities.\nas of today, µShip does not go further - as providing a configuration/openmetrics/opentracing/JWT integration since these ones can easily be added using CDI libraries. It will probably be tackled in a few versions but was not a pre-requisite of the project.\nRead more.\nBy using CDI standalone (a.k.a. CDI SE) and an embedded Apache Tomcat, µShip enables to deliver application as:\nAssemblies (just use java -cp folder-with-dependencies-and-application-jars/*.jar com.app.YourMain - or reuse µShip main),\nDocker images using jib-maven-plugin.\nby using a flat classpath, µShip is perfectly compatible with java CDS which boosts a lot the startup in general, don’t hesitate to set it up if you care to start in less than a second.\nOnce again, by using a plain CDI base, testing is made easy and compatible with Apache OpenWebBeans tooling.\nUShip extends the JVM HttpClient to provide a few more features and callbacks. It also provides a Kubernetes client module which auto-setup a HttpClient from a POD.","title":"Getting Started","url":"//yupiik.github.io/uship/getting-started.html"},{"lang":"en","lvl2":"Request Listeners\nKubernetes client","lvl3":"Default Listeners\nSample usage","text":"UShip HTTP Client is based on java.net.http.HttpClient. It is configured with ExtendedHttpClientConfiguration which enables to:\noptionally provide a configured HttpClient instance - otherwise the default JVM one is used,\noptionally provide a set of `RequestListener`s which listen for requests.\nRequest listener is a callback triggered before and after each request. It enables to store data before the requests in the caller context and execute some callback once the request is finished. To pass data between both steps (since the request can be asynchronous or not) it uses a State which can hold any data the listener needs.\nif you write custom listeners (to add OpenTracing capabilities for example), you can make them implement AutoCloseable and when closing the HTTP client the method will be called automatically.\nThis listener is pretty straight forward, if the request does not have a timeout, it sets it to the default one configured in the listener. It enables to enforce a global timeout to all requests.\nThis listener enforce a custom user-agent value. It defaults to chrome one.\nThis listener enables to force all exchanges to be logged.\nThis listener enables to capture a HAR dump of all exchanges which went through the client. It can be very useful to generate some test data you replay with a HAR server in a test or a demo environment.\nkubernetes-client modules providers a HTTP Client already configured for Kubernetes in cluster connection (from a POD). This will typically be used from an operator or cloud native application to call Kubernetes API using a plain and very light HTTP Client from the JVM.\nindeed you can combine it with the enhanced HTTP Client configuring it in the KubernetesClientConfiguration. However, it is recommended to do it using setClientWrapper on the configuration and pass the automatically created client to ExtendedHttpClientConfiguration.setDelegate to avoid to have to handle the SSLContext yourself.\nUsage:\nas you can see, there is no need to pass the token to the request, it is done under the hood by the KubernetesClient. The other important note is that https://kubernetes.api is automatically replaced by the conf.getMaster() value. This enables your code to stay more straight forward in general but if you pass them, the client will handle it properly too.","title":"HTTP Client","url":"//yupiik.github.io/uship/http-client.html"},{"lang":"en","lvl2":"Modes\nStandalone mode\nCDI Mode","text":"µship comes with two Tomcat modules:\nwebserver-tomcat which is a thin Apache Tomcat wrapper creating - by default - a ROOT context,\nwebserver-cdi which integrated webserver-tomcat with CDI.\nThe standalone mode (webserver-tomcat) is mainly about creating a TomcatWebServerConfiguration and instantiating a TomcatWebServer:\nCreate a configuration instance,\nYou can bind any servlet, filter etc using initializers,\nCreate a server (create call is what starts the server) and don’t forget to close is when no more needed (done with try-with-resource syntax there),\nThe port can be random using 0 in the original configuration, it will be updated after the startup of the server in this case.\ndefault Tomcat scanning (@WebServlet etc) is not enabled - you will see that with CDI it is rarely needed - but you can enable it adding a context customizer registering ContextConfig:\n+\nCDI mode is almost the same as standalone mode except:\nYou can (optional) produce TomcatWebServerConfiguration in CDI context:\nIt can be a standard subclass of the POJO TomcatWebServerConfiguration or like here a producer, in all cases it is recommended to use @ApplicationScoped even if not required to ensure the instance is shared between injection if you reuse it soewhere else (like in tests or in a servlet),\nCreate the configuration (same as standalone case), here te trick is generally to reuse the native configuration mecanism of the application (microprofile config for example),\nAdd a context customizer to customize the docbase, context name etc…\nYou can (optional) create ServletContextInitializer, ContextCustomizer and TomcatCustomizer beans (with @Default qualifier) which will automatically be injected in the TomcatWebServerConfiguration.\nno need of a META-INF/services/jakarta.servlet.ServletContainerInitializer file in this case, CDI is the registry used.","title":"HTTP Server","url":"//yupiik.github.io/uship/http-server.html"},{"lang":"en","text":"","title":"Index","url":"//yupiik.github.io/uship/index.html"},{"lang":"en","lvl2":"Launcher\nCreate docker images","text":"To launch UShip, you just have to launch a CDI SE container. Using default implementation - Apache OpenWebBeans - it can be done using the default main(String…): org.apache.openwebbeans.se.CDILauncher. For the web server you can use --openwebbeans.main uShipTomcatAwait argument with CDILauncher to await Tomcat server and not quit immediately.\nOnce you collected all dependencies to be able to build the application classpath, simply set this class a your main and your application will start.\nWe highly recommend using JIB to create the docker images but you can also use a plain Dockerfile if desired. This documentation will use jib to provide an end to end example.\nHere is how to define Jib plugin to create a docker image:\nOnce configured you can build a local docker image using: mvn package jib:dockerBuild.\nusing mvn package jib:build, you can push the image to a remote registry without docker daemon. See jib documentation for more details.","title":"Packaging","url":"//yupiik.github.io/uship/packaging.html"},{"lang":"en","lvl2":"Testing an UShip application","text":"Testing an UShip application just requires to launch a CDI container. By default we rely on org.apache.openwebbeans:openwebbeans-junit5 to do so. It enables to start the container marking the test class with @Cdi:\nMark the test class to need a CDI SE container,\n@Cdi makes the test instance injections aware,\nThen simply write your tests as usual.\n@Cdi has some configuration options. One of the most interesting is to set reusable = true. It will enable to use the same container for all tests. Since, with this mode, all tests of the suite (configurable in surefire) must use the same flag, you can define a JUnit 5 stereotype:\nNow, instead of using @Cdi, you can use @MyAppSupport on test classes avoiding to miss a reusable = true configuration. It is also very useful to add extension to all tests at once, for example if you have some JPA enhancer to execute before the container starts or some entity spying to auto delete test data between test, you can add the extensions there:\nThe test will then not change:","title":"Testing","url":"//yupiik.github.io/uship/testing.html"},{"lang":"en","lvl2":"Setup your JSON-RPC service with µship stack\nCreate JSON-RPC endpoints\nDocument JSON-RPC endpoints\nGoing further","text":"To get started, you have to create a new project. This part will use Maven to illustrate the process but it is easily adaptable to Gradle or any Java based project.\nTo create a new Apache Maven project, you can use mvn archetype:generate but we recommend you to just create a folder and manually write a pom to avoid to inherit from a legacy setup.\nHere is a pom.xml template you can use to get started:\nEnsure to define your project metadata, note that this setup will be compatible with a multi-module project too,\nDefine uship version as a variable for easier upgrades (not required),\nWe use Yupiik Logging to get a more cloud friendly logging but this is not required at all, skip this dependency if not desired (if you prefer Log4j2 or so use JUL binding for example),\nWe want to write tests with JUnit 5 so we set it as dependency,\nJUnit 5.8.0-M1 got a pom bug so we force kotlin exclusion to workaround it,\nWe import the UShip bom to get dependencies versions right,\nWe force the encoding for resources to avoid surprises (OS dependent otherwise),\nWe force the compiler to use the Java version we want (note you can use any version >= 11),\nWe force surefire version to ensure we are JUnit 5 compatible,\nWe prevent surefire to trim the stack when an exception is thrown - it swallows the information you need to understand why it failed in general,\nWe force Yupiik logging manager (if you don’t use Yupiik Logging, skip it).\nµship does not use a parent pom to set it up automatically because: 1. it can quickly get outdated with transitive dependencies and project must be able to update any of the plugin/dependencies without a new µship release for flexibility, 2. you can use other plugins (junit-platform-maven-plugin instead of maven-surefire-plugin for example, spock, etc…), 3. it is saner to use a project related parent than a cross-project parent which is a bad practise and breaks several Maven features/integrations.\nAt that stage we have a good \"parent\" pom but to be able to code against it you should add the related dependencies. The simplest is to add this dependency:\nFrom here you can develop JSON-RPC endpoints.\nCreating a JSON-RPC endpoint is about marking a bean with the qualifier @JsonRpc and some method(s) with @JsonRpcMethod:\nDefines the class as containing JSON-RPC methods,\nSince the class will match a CDI bean, it can use any relevant scope. We strongly encourage you to use @ApplicationScoped if possible for performances and consistency but it is not required,\n@JsonRpcMethod defines a method usable over JSON-RPC transport (a servlet by default). The name attribute must be unique per deployment and we highly recommend you to set the documentation attribute,\nThe method can then define its return type and inputs as any JSON-B friendly types. Inputs can be marked with @JsonRpcParam to set their documentation.\nthe JSON-RPC implementation supports by position calls (parameters are passed in order) or names (JsonRpcParam#value). If not explicitly set, the name is taken from the parameter bytecode name. It is highly recommended to set -parameters to javac to get the same names than in the source code. Also take care that the order and names are then part of your contract.\nIf fully described - documentation methods being set in annotations, you can generate your endpoint documentation using jsonrpc-documentation module and in particular io.yupiik.uship.jsonrpc.doc.AsciidoctorJsonRpcDocumentationGenerator class.\nYou have to add this dependency to your pom.xml:\nThen add new exec build plugin instructions:\nWill generate a textual (Asciidoctor) documentation of your contract from the classes listed in the arguments,\nWill generate an OpenRPC (JSON) contract from the classes listed in the arguments.\nIt is possible to enrich the JSON-RPC protocol, in particular bulk request support, by reusing io.yupiik.uship.jsonrpc.core.impl.JsonRpcHandler class in your own endpoints. Typical examples are endpoint wrapping a set of request (sub methods), in a single transaction, endpoints propagating a state between method calls (like the second method will get the id generated in the first one), etc…","title":"Usage","url":"//yupiik.github.io/uship/development-stack.html"}]