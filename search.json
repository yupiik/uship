[{"lang":"en","lvl2":"Pre-requisites\nDevelopment stack\nDeployment capabilities/integration\nTesting\nHTTP Server\nHTTP Client\nPersistence\nSpring Boot\nQuarkus\nMicroprofile","text":"Ensure to use java >= 11\n(Optional) Ensure to use a dependency manager such as Apache Maven/Gradle/SBT or Apache Ivy.\nusing SDKMan can greatly simplify the installation.\nThe goal of µShip is to promote and enable JSON-RPC development at scale. For that it provides a CDI-Servlet integration module known as jsonrpc-core module.\nHowever, µShip also provides all the underlying stack to make it functional such as:\nAn embedded Servlet container (Apache Tomcat),\nJSON-P/JSON-B integration modules,\nJSON-RPC API/implementation and documentation utilities.\nas of today, µShip does not go further - as providing a configuration/openmetrics/opentracing/JWT integration since these ones can easily be added using CDI libraries. It will probably be tackled in a few versions but was not a pre-requisite of the project.\nRead more.\nBy using CDI standalone (a.k.a. CDI SE) and an embedded Apache Tomcat, µShip enables to deliver application as:\nAssemblies (just use java -cp folder-with-dependencies-and-application-jars/*.jar com.app.YourMain - or reuse µShip main),\nDocker images using jib-maven-plugin.\nby using a flat classpath, µShip is perfectly compatible with java CDS which boosts a lot the startup in general, don’t hesitate to set it up if you care to start in less than a second.\nOnce again, by using a plain CDI base, testing is made easy and compatible with Apache OpenWebBeans tooling.\nUShip extends the JVM HttpClient to provide a few more features and callbacks. It also provides a Kubernetes client module which auto-setup a HttpClient from a POD.\nUShip provides a convenient JDBC light mapper.\nIf you want a Spring Boot JSON-RPC integration, you can reuse our jsonrpc-spring module.\nIf you want a Quarkus JSON-RPC integration, you can reuse our jsonrpc-quarkus module.\nIf you want a Microprofile JSON-RPC integration, you can reuse our jsonrpc-core module with some minimal setup.","title":"Getting Started","url":"//yupiik.github.io/uship/getting-started.html"},{"lang":"en","lvl2":"Request Listeners\nKubernetes client\nJSON-RPC client","lvl3":"Default Listeners\nSample usage\nBulk handling","text":"UShip HTTP Client is based on java.net.http.HttpClient. It is configured with ExtendedHttpClientConfiguration which enables to:\noptionally provide a configured HttpClient instance - otherwise the default JVM one is used,\noptionally provide a set of `RequestListener`s which listen for requests.\nRequest listener is a callback triggered before and after each request. It enables to store data before the requests in the caller context and execute some callback once the request is finished. To pass data between both steps (since the request can be asynchronous or not) it uses a State which can hold any data the listener needs.\nif you write custom listeners (to add OpenTracing capabilities for example), you can make them implement AutoCloseable and when closing the HTTP client the method will be called automatically.\nThis listener is pretty straight forward, if the request does not have a timeout, it sets it to the default one configured in the listener. It enables to enforce a global timeout to all requests.\nThis listener enforce a custom user-agent value. It defaults to chrome one.\nThis listener enables to force all exchanges to be logged.\nThis listener enables to capture a HAR dump of all exchanges which went through the client. It can be very useful to generate some test data you replay with a HAR server in a test or a demo environment.\nkubernetes-client modules providers a HTTP Client already configured for Kubernetes in cluster connection (from a POD). This will typically be used from an operator or cloud native application to call Kubernetes API using a plain and very light HTTP Client from the JVM.\nindeed you can combine it with the enhanced HTTP Client configuring it in the KubernetesClientConfiguration. However, it is recommended to do it using setClientWrapper on the configuration and pass the automatically created client to ExtendedHttpClientConfiguration.setDelegate to avoid to have to handle the SSLContext yourself.\nUsage:\nas you can see, there is no need to pass the token to the request, it is done under the hood by the KubernetesClient. The other important note is that https://kubernetes.api is automatically replaced by the conf.getMaster() value. This enables your code to stay more straight forward in general but if you pass them, the client will handle it properly too.\nAs a JSON-RPC server companion UShip also provides a JSON-RPC client.\nThe minimum configuration is to provide the JSON-RPC endpoint:\nBut more is customizable in JsonRpcClientConfiguration and a common initialization would look like:\nThen you can simply use it in your application:\nBulk is handled relying on the JSON-RPC protocol accessible from the client - or directly if you prefer:","title":"HTTP Client","url":"//yupiik.github.io/uship/http-client.html"},{"lang":"en","lvl2":"Modes\nStandalone mode\nCDI Mode","text":"µship comes with two Tomcat modules:\nwebserver-tomcat which is a thin Apache Tomcat wrapper creating - by default - a ROOT context,\nwebserver-cdi which integrated webserver-tomcat with CDI.\nThe standalone mode (webserver-tomcat) is mainly about creating a TomcatWebServerConfiguration and instantiating a TomcatWebServer:\nCreate a configuration instance,\nYou can bind any servlet, filter etc using initializers,\nCreate a server (create call is what starts the server) and don’t forget to close is when no more needed (done with try-with-resource syntax there),\nThe port can be random using 0 in the original configuration, it will be updated after the startup of the server in this case.\ndefault Tomcat scanning (@WebServlet etc) is not enabled - you will see that with CDI it is rarely needed - but you can enable it adding a context customizer registering ContextConfig:\n+\nCDI mode is almost the same as standalone mode except:\nYou can (optional) produce TomcatWebServerConfiguration in CDI context:\nIt can be a standard subclass of the POJO TomcatWebServerConfiguration or like here a producer, in all cases it is recommended to use @ApplicationScoped even if not required to ensure the instance is shared between injection if you reuse it soewhere else (like in tests or in a servlet),\nCreate the configuration (same as standalone case), here te trick is generally to reuse the native configuration mecanism of the application (microprofile config for example),\nAdd a context customizer to customize the docbase, context name etc…\nYou can (optional) create ServletContextInitializer, ContextCustomizer and TomcatCustomizer beans (with @Default qualifier) which will automatically be injected in the TomcatWebServerConfiguration.\nno need of a META-INF/services/jakarta.servlet.ServletContainerInitializer file in this case, CDI is the registry used.","title":"HTTP Server","url":"//yupiik.github.io/uship/http-server.html"},{"lang":"en","text":"","title":"Index","url":"//yupiik.github.io/uship/index.html"},{"lang":"en","lvl2":"For Microprofile servers with Servlet layer\nYour microprofile server does not have Servlet layer","text":"JSON-RPC server can easily be integrated with a Microprofile server.\nThe entry point is the module io.yupiik.uship:jsonrpc-core.\nthis is for jakarta based Microprofile servers, for javax one you need to redefine a few beans, you can check out jsonrpc-quarkus module for a sample.\nTo enable the server you can create a META-INF/services/jakarta.servlet.ServletContainerInitializer file in your resources registering io.yupiik.uship.jsonrpc.core.servlet.JsonRpcServletRegistration servlet. If you don’t want to bind /jsonrpc servlet, just register the servlet yourself on another binding instead of reusing default one.\nThe complete dependency set would look like:\nIf you use one of the very rare Microprofile server not having a servlet layer you can need to register the servlet different or a @POST JAX-RS endpoint delegating to JsonRpcServlet (but this is generally not needed):\nOnce done you can implement JSON-RPC methods using beans marked with @JsonRpc and methods with @JsonRpcMethod as in plain UShip server,","title":"Microprofile","url":"//yupiik.github.io/uship/microprofile.html"},{"lang":"en","lvl2":"Launcher\nCreate docker images","text":"To launch UShip, you just have to launch a CDI SE container. Using default implementation - Apache OpenWebBeans - it can be done using the default main(String…): org.apache.openwebbeans.se.CDILauncher. For the web server you can use --openwebbeans.main uShipTomcatAwait argument with CDILauncher to await Tomcat server and not quit immediately.\nOnce you collected all dependencies to be able to build the application classpath, simply set this class a your main and your application will start.\nWe highly recommend using JIB to create the docker images but you can also use a plain Dockerfile if desired. This documentation will use jib to provide an end to end example.\nHere is how to define Jib plugin to create a docker image:\nOnce configured you can build a local docker image using: mvn package jib:dockerBuild.\nusing mvn package jib:build, you can push the image to a remote registry without docker daemon. See jib documentation for more details.","title":"Packaging","url":"//yupiik.github.io/uship/packaging.html"},{"lang":"en","text":"JSON-RPC server is integrated with Quarkus.\nThe entry point is the module io.yupiik.uship:jsonrpc-quarkus. Once added you can:\nimplement JSON-RPC methods using beans marked with @JsonRpc and methods with @JsonRpcMethod,\nconfigure the base url of the OpenRPC value using jsonrpc.baseUrl (defaults to try to use localhost and the quarkus port) and jsonrpc.binding to configure the servlet binding in microprofile-config (application.properties), it defaults to /jsonrpc.\nHere is a sample:","title":"Quarkus","url":"//yupiik.github.io/uship/quarkus.html"},{"lang":"en","text":"JSON-RPC server is integrated with Spring Boot.\nThe entry point is the module io.yupiik.uship:jsonrpc-spring. Once added you can:\nmark your application with @EnableJsonRpc,\nimplement JSON-RPC methods using beans marked with @JsonRpc and methods with @JsonRpcMethod,\nconfigure the base url of the OpenRPC value using jsonrpc.baseUrl and binding url of the JSON-RPC endpoint with jsonrpc.binding in your application.properties (default uses the spring web server).\nHere is a sample:","title":"Spring Boot","url":"//yupiik.github.io/uship/spring-boot.html"},{"lang":"en","lvl2":"Testing an UShip application","text":"Testing an UShip application just requires to launch a CDI container. By default we rely on org.apache.openwebbeans:openwebbeans-junit5 to do so. It enables to start the container marking the test class with @Cdi:\nMark the test class to need a CDI SE container,\n@Cdi makes the test instance injections aware,\nThen simply write your tests as usual.\n@Cdi has some configuration options. One of the most interesting is to set reusable = true. It will enable to use the same container for all tests. Since, with this mode, all tests of the suite (configurable in surefire) must use the same flag, you can define a JUnit 5 stereotype:\nNow, instead of using @Cdi, you can use @MyAppSupport on test classes avoiding to miss a reusable = true configuration. It is also very useful to add extension to all tests at once, for example if you have some JPA enhancer to execute before the container starts or some entity spying to auto delete test data between test, you can add the extensions there:\nThe test will then not change:","title":"Testing","url":"//yupiik.github.io/uship/testing.html"},{"lang":"en","lvl2":"Setup your JSON-RPC service with µship stack\nCreate JSON-RPC endpoints\nDocument JSON-RPC endpoints\nPostman collection for JSON-RPC endpoint\nPersistence\nGoing further","lvl3":"Advanced queries\nQuery from interfaces","text":"To get started, you have to create a new project. This part will use Maven to illustrate the process but it is easily adaptable to Gradle or any Java based project.\nTo create a new Apache Maven project, you can use mvn archetype:generate but we recommend you to just create a folder and manually write a pom to avoid to inherit from a legacy setup.\nHere is a pom.xml template you can use to get started:\nEnsure to define your project metadata, note that this setup will be compatible with a multi-module project too,\nDefine uship version as a variable for easier upgrades (not required),\nWe use Yupiik Logging to get a more cloud friendly logging but this is not required at all, skip this dependency if not desired (if you prefer Log4j2 or so use JUL binding for example),\nWe want to write tests with JUnit 5 so we set it as dependency,\nJUnit 5.8.0-M1 got a pom bug so we force kotlin exclusion to workaround it,\nWe import the UShip bom to get dependencies versions right,\nWe force the encoding for resources to avoid surprises (OS dependent otherwise),\nWe force the compiler to use the Java version we want (note you can use any version >= 11),\nWe force surefire version to ensure we are JUnit 5 compatible,\nWe prevent surefire to trim the stack when an exception is thrown - it swallows the information you need to understand why it failed in general,\nWe force Yupiik logging manager (if you don’t use Yupiik Logging, skip it).\nµship does not use a parent pom to set it up automatically because: 1. it can quickly get outdated with transitive dependencies and project must be able to update any of the plugin/dependencies without a new µship release for flexibility, 2. you can use other plugins (junit-platform-maven-plugin instead of maven-surefire-plugin for example, spock, etc…), 3. it is saner to use a project related parent than a cross-project parent which is a bad practise and breaks several Maven features/integrations.\nAt that stage we have a good \"parent\" pom but to be able to code against it you should add the related dependencies. The simplest is to add this dependency:\nFrom here you can develop JSON-RPC endpoints.\nCreating a JSON-RPC endpoint is about marking a bean with the qualifier @JsonRpc and some method(s) with @JsonRpcMethod:\nDefines the class as containing JSON-RPC methods,\nSince the class will match a CDI bean, it can use any relevant scope. We strongly encourage you to use @ApplicationScoped if possible for performances and consistency but it is not required,\n@JsonRpcMethod defines a method usable over JSON-RPC transport (a servlet by default). The name attribute must be unique per deployment and we highly recommend you to set the documentation attribute,\nThe method can then define its return type and inputs as any JSON-B friendly types. Inputs can be marked with @JsonRpcParam to set their documentation.\nthe JSON-RPC implementation supports by position calls (parameters are passed in order) or names (JsonRpcParam#value). If not explicitly set, the name is taken from the parameter bytecode name. It is highly recommended to set -parameters to javac to get the same names than in the source code. Also take care that the order and names are then part of your contract.\nIf fully described - documentation methods being set in annotations, you can generate your endpoint documentation using jsonrpc-documentation module and in particular io.yupiik.uship.jsonrpc.doc.AsciidoctorJsonRpcDocumentationGenerator class.\nYou have to add this dependency to your pom.xml:\nThen add new exec build plugin instructions:\nWill generate a textual (Asciidoctor) documentation of your contract from the classes listed in the arguments,\nWill generate an OpenRPC (JSON) contract from the classes listed in the arguments.\nSimilarly to Asciidoctor documentation you can generate a collection of JSON-RPC requests using PostmanCollectionGenerator main. It takes an OpenRPC file (you can get it with openrpc method) and output a Postman collection file.\nSince UShip is mainly CDI based, it will be compatible with any kind of persistence Layer from SQL to NoSQL. However, for common simple cases, we ship a small JDBC mapper in our io.yupiik.uship:persistence module.\nIts scope is not to replace JPA but for simple cases to just provide a very light ORB. It only supports flat mapping - relationships must be managed by your which also means no magic or lazy query ;) - and transactions are managed through the DataSource. It works if the Connection is in autocommit mode or if you handle the commit through a transactional interceptor for example.\nThe entry point is the Database.of(configuration) factory then all operations are available on the database instance.\nHere some examples:\nMapping is a simple as:\nFor more advanced cases you can use query and batch methods from the Database instance.\nFor advanced queries you can use a virtual table (it is a plain table but the @Table annotation is ignored) which would be used as project based on query aliases:\nwith JoinModel being something like:\nOr you can also use Entity binder capacity:\n1.0.2 was broken, ensure to use >= 1.0.3 to get this feature.\nA light interface statement support is done through @Operation and @Statement annotations. The idea is to expose the Database capabilities through a statically typed API. Here is a sample:\nThe statements can be plain SQL with ? bindings or can use the available interpolations (but don’t mix ${parameters#xxx} with ? bindings, you must choose one type of binding per statement):\n${<alias>#table}: name of the table of the entity aliased by alias,\n${<alias>#fields}: all columns of the entity represented by the alias,\n${parameters#<name>}: will be replaced by a ? binding and the parameter named name (using bytecode name, ensure to compile with -parameter flag) will be used. It enables to not set the parameters in the same order than in the query because otherwise it is just bound blindly in order.\n${parameters#<name>#in}: will be replaced by as much ? than the size of the parameter name and surround the bindings by parenthesis prefixed by in ` keyword (ex: `in (?, ?) if name parameter is a list of 2 items). It is useful for in where clauses.\nAliases are defined through @Operation annotation on the interface and enables to have a shorter syntax in the statement. You can also use the fully qualified name of the entity instead of defining aliases but it is less readable.\nIt is possible to enrich the JSON-RPC protocol, in particular bulk request support, by reusing io.yupiik.uship.jsonrpc.core.impl.JsonRpcHandler class in your own endpoints. Typical examples are endpoint wrapping a set of request (sub methods), in a single transaction, endpoints propagating a state between method calls (like the second method will get the id generated in the first one), etc…","title":"Usage","url":"//yupiik.github.io/uship/development-stack.html"}]